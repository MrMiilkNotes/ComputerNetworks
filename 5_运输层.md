## 运输层干了什么

​	网络层为主机之间提供逻辑通讯，而运输层为应用程序之间提供端到端的逻辑通讯。“从主机到应用程序”的这种拓展即运输层最重要的工作。

>  **multiplexing**和**demultiplexing**，即发送方多个应用进程能用同一个运输层协议传送，接收方能在解析完头部后正确交付数据，这两个机制基于传输层的协议端口号，利用传输端口号做进程区分。

​	其实只要做到这个，传输层最简陋的结构就起来了，但是网络层的IP数据报在传输运输层数据的时候，其首部检验和字段检验的只有首部(毕竟每个路由器都要计算一遍，因此不能怪网络层)，所以传输层也需要加一个检验和，增加检验和后其实就是UDP了。

​	运输层能拓展的其实有很多，TCP应当是运输层最完备的协议，它拓展的功能基本能分为三个方向，具体的会在后面说到，从TCP的拓展中能看到，互联网的复杂性导致很难找到纯粹的优化算法解决问题，大部分算法都有一定缺陷，从而又需要打个补丁。

> 逻辑通讯：只要把数据丢给下一层，下一层就可以把数据交付到对方的本层

​	**面向通讯的最高层，用户功能的最底层，屏蔽了网络核心部分的细节，提供应用程序间的端到端的“逻辑信道”**

### 协议端口号(protocol port number)

​	"协议栈层间的抽象的协议端口，和路由,交换机的硬件端口毫无关系"，可以将这个端口理解为“门牌”，通过IP地址传到本机后通过“门牌”区分应用程序

​	通常端口分为服务器端使用端口和用户端使用端口(49152-65535)，其中服务器端使用端口又分为**系统端口**(0-1023)和登记端口(1024-49151)

<img src="5_运输层.assets/1573001746276.png" alt="1573001746276" style="zoom:25%;" />

### 协议

​	运输层的两个主要协议代表的近乎是两种极端。UDP类似“传输层”实现的**最小集**，即运输层的满足基本要求，而TCP则是加入了对可靠性的要求，相对地也牺牲了一定的性能。

## UDP

​	用户数据报协议

​	所谓**最小集**，除了提供进程级端到端的通讯，其实现的基本功能差不多只有**multiplexing**，**demultiplexing**和差错检验。对UDP的理解可以从其特性出发，

- UDP是无连接的，支持单点和多点的任意组合的通讯

- UDP在可靠性上没有付出什么努力，因此依旧是“尽最大努力交付”而且没有拥塞控制

  > 这里所谓拥塞控制，包括了之前ICMP提到的一些功能，比如源点抑制，信道堵塞等
  >
  > <font color='red'>UDP不会使用ICMP？ICMP若属于网络层，那为什么说UDP不能提供拥塞控制？</font>

- UDP的“最小集”实现让它的首部只有8字节

- “面向报文”的。不会拆分数据，直接交付来自应用程序的完整报文，报文的长度由应用程序负责控制

### 首部

<img src="5_运输层.assets/1573002691587.png" alt="1573002691587" style="zoom: 33%;" />

非常“naive”。这里的伪首部是后面用于计算检验和的时候使用的，实际的UDP并没有这部分。

**检验和计算**

​	检验和的计算和IP头部检验和计算类似，但是会加入伪首部。

## TCP

​	传输控制协议

​	在“最小集”的基础上加入三个基本机制：可靠传输(建立连接)，流量控制，拥塞控制。

> 在讨论TCP的时候，可靠传输指的通常是建立连接。

​	TCP的特点：

- 面向连接的，只能点对点的通讯，支持全双工通信

  > 这里的点(endpoint)是指socket

- 可靠交付

- “面向字节流”。对于TCP来说传输什么无所谓(都是无结构的0，1流)

### 首部

<img src="5_运输层.assets/1573006658544.png" alt="1573006658544" style="zoom: 80%;" />

​	选项字段最多为40字节

**序号，确认号**

​	TCP 连接中传送的数据流中的**每一个字节**都有一个序号。序号字段的值指的是本报文段所发送的数据的第一个字节的(在整个要发送的数据的)序号。而确认号是期望收到对方的下一个报文段的数据的第一个字节的序号  

**数据偏移**

​	指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，单位是32位。

**几个信息位**

| 名称 | 作用                                                         |
| ---- | ------------------------------------------------------------ |
| URG  | 紧急数据or高优先级                                           |
| ACK  | ACK应答，为1时确认号才有效，TCP规定连接建立后ACK必须为1      |
| PSH  | 目标主机接收到这个数据后应当尽快交付应用程序，而不是等到缓存区填满 |
| RST  | (由于连接崩溃)要求重置连接                                   |
| SYN  | 连接请求或接收连接                                           |
| FIN  | (数据发送完成)要求释放连接                                   |

**窗口**

​	指出发送方的窗口大小 -> 允许对方发送的数据量，可以作为对方设置其窗口大小的依据，经常变化。

**检验和**

​	同样需要加上伪首部

**紧急指针**

​	当设置了URG后，这个字段指出在本报文段中紧急数据共有多少个字节 

**选项**

| 选项                |                                                              |
| ------------------- | ------------------------------------------------------------ |
| MSS(最大报文段长度) | **数据段**的最大长度。和接收窗口没有关系。为了增加利用率(IP+TCP头部就40字节了)，也为了避免在网络层分片。通常是一方设定好后通知另一方 |
| 窗口扩大选项        | 把 TCP 首部中的窗口位数增大到 (16 + S)，S最大为14。像是卫星链路，需要大的窗口 |
| 时间戳选项          | 可以计算RTT，用于处理序号绕回                                |
| 选择确认选项        |                                                              |

### 可靠传输(建立连接)

#### 1.连接

​	TCP经常会被称为“TCP连接”，因为TCP最大的特点就是这个连接。TCP既然是连接，那第一个问题就是连接的是什么 -- endpoint，它是IP和protocol port的结合，称为socket
$$
TCP\ connection ::=\{socket_1, socket_2\}::=\{(IP_1:port_1),(IP_2,port_2)\}
$$

​	这个式子可以当成TCP连接的表示，但是它表示的更像一种P2P，应当正确理解连接表示的应当是包括，三次握手建立连接，使用ARQ的方式传输，四次挥手断开连接。

##### 三次握手

<img src="5_运输层.assets/image-20191112085634181.png" alt="image-20191112085634181" style="zoom:80%;" />

​	回复ACK的时候，如果没有携带数据，就不需要消耗序号，即下一个报文的序号依旧是x+1。	

##### 四次挥手

<img src="5_运输层.assets/image-20191112085551809.png" alt="image-20191112085551809" style="zoom: 80%;" />

连接释放的时候可能存在半关闭状态，注意服务器回复ACK与自己最后关闭的ACK都是u+1

##### TCP有限状态机

<img src="5_运输层.assets/yU3mMv.jpg" alt="yU3mMv" style="zoom:67%;" />

当通讯双方同时打开连接的时候会出现两者从CLOSED->SYN_SENT->SYN_RECVD的状态变化。



> ​	课本给出了停止等待协议的讲解，但是又说明停止等待协议属于早期链路层，和运输层没关系，总的来说，这部分内容给出了两个知识点
>
> ​	自动重传请求(ARQ)：即接收方发送ACK来确认收到的分组，而不必担心出错的分组，因为发送方会自动重传
>
> ​	流水线传输：发送分组的时候不必等待上一个分组的确认消息，而是不断发送
>
> <img src="5_运输层.assets/1573453874172.png" alt="1573453874172" style="zoom: 50%;" />

**连续ARQ协议**

​	维持一个发送窗口，基于ACK的应答来滑动这个窗口，窗口内的数据是可以以流水线方式发送的。ACK的应答采用**累计确认**的方式

#### 2.滑动窗口

**滑动窗口**

​	**单位为字节**。只有在窗口内的数据允许发送和接收。TCP头部的窗口字段会协助双方窗口大小的配置，由于窗口值传输存在滞后，网络拥塞可能导致发送方减小窗口大小等，双方窗口大小会不一样。

​	注意区分发送缓存的发送窗口，发送窗口通常是发送缓存的真子集，它们的后沿部分通常是重叠的，实际使用的发送缓存区会设计为环形队列

​	发送窗口对应的接收窗口的设计，有利于处理数据不按序到达的情况。

​	TCP要求**必须实现累计确认功能**，这样可以减少传输开销。

<img src="5_运输层.assets/1573009885350.png" alt="1573009885350" style="zoom:80%;" />

#### 3.重传时间确认

​	按ARQ协议，发送方若没有收到ACK，说明接收方没有接收到帧，应当进行重传，重传一时爽，但问题是**如何确定重传的时间？**，有可能ACK只是到达比较慢而已。

​	**计算方式**: 基本思想是利用TCP数据报中的时间戳选项计算RTT，然后估算一个超时的时间，设置到超时计时器，超时后就直接重传。

- 报文段的**往返时间**，使用滑动平均计算

$$
(RTT_s)_{new}=(1-\alpha)×(RTT_s)_{old}+\alpha×(RTT)_{new}
$$

​	$RTT_s$称为平滑的往返时间，第一次计算时取值为$RTT_{new}$，推荐取值：$\alpha=0.125$

- 超时计时器设置的超时重传时间RTO

$$
RTO=RTT_s+4×RTT_D
$$

​	其中$RTT_D$是$RTT$的**偏差的加权平均值**，第一次测量时取为$RTT$的一半，之后的计算：
$$
(RTT_D)_{new}=(1-\beta)×(RTT_D)_{old}+\beta×|(RTT_s)_{old}-RTT_{new}|
$$
​	推荐$\beta=0.25$。

**问题**

​	这种计算方式遇到的最大的问题是，当一个帧重传后收到确认消息，无法判断ACK属于前面哪个帧。

- 有一个策略(**Karn算法**)是只要报文重传，就不使用这个报文进行$RTT$的计算。但是这样的话，当超时报文突然增多的时候就无法及时更新$RTT$
- 因此需要对**Karn算法**进行修正，当报文重传的时候就增大RTO(而不是不变)，增大的方式是×2

#### 选择确认SACK

​	经过前面的讨论，一个比较可能有的想法是“能不能设法只重传缺少的数据”。SACK就是干这事的，它用TCP的选项字段描述需要重传的**帧范围**，由于选项字段最多为40字节，而且需要占用两个字节描述SACK，因此最多能描述4个缺失范围

​	缺失范围的描述使用的是边界描述。

<img src="5_运输层.assets/1573021690085.png" alt="1573021690085" style="zoom:67%;" />

### 流量控制

​	“发送方的发送速率不要太快，要让接收方来得及接收”，这个解决的问题有点类似“同步”，在MAC层，同步是通过前导码来解决的，它的同步是指频率上的同步，而这里虽然称“同步”，但是它是离散的(以帧or多个字节为单位)，只是整体看起来接收端和发送端在实现一种“收发平衡”。

#### 1.基于滑动窗口的流量控制

​	通过滑动窗口的机制就能实现流量控制了。如果接收方的处理相对缓慢，可能会对*rwnd*(接收窗口)进行调整，但是这种调整有可能出现接收方的缓存满了，将*rwnd*调整为0，而之后发送方发送的重新调整接收窗口的帧丢失而引起死锁，因此当发送方收到0窗口通知后会启动**持续计时器**，计时到达后会发送探测报文询问接收方。

#### 2.传输效率问题

​	滑动窗口回答了怎么发送数据的问题，还有另一个问题是何时发送？因为较差的发送策略可能导致一个IP数据报中带了40字节控制信息，而只有几字节的数据。三个基本机制：

- 当缓存的数据量达到最大报文长度
- 当设置的计时器期限到达后
- 应用程序要求push

##### a.发送方糊涂窗口综合症

​	发送方 TCP 每次接收到应用程序发到缓存的一字节的数据后就发送  

**Nagle算法**

- 若发送应用进程把要发送的数据逐个字节地送到 TCP 的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来  

- 当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存

- <font color=red>只有在收到对前一个报文段的确认后才继续发送下一个报文段</font>

  > 当缓存满的时候(或者缓存填充迅速)使用流水线方式，可以提高效率，因为每个帧都能传输较多数据。但是当缓存填充缓慢的时候使用流水线方式会降低**每个帧的利用率**从而使得互联网整体的效率变低，这种时候使用上面的方式，效率会更高

- 当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段  

##### b.接收方糊涂窗口综合症  

​	当接收方的 TCP 缓冲区已满，接收方会向发送方*rwnd*大小为 0 的报文，这时候如果进程从缓存读取的速度缓慢(比如每次读取一字节的交互式程序)，就可能出现每当缓存有很小的空间就通知发送方，而发送过来的数据又马上把缓冲区填满....  

**solution**：启发式

​	让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间  

### 拥塞控制

​	注意区分拥塞控制和流量控制。流量控制描述的是端和端之间的问题，属于局部问题。而拥塞控制描述的是整个互联网的问题，是一种全局过程，指的是防止过多的数据注入互联网，避免网络核心部分过载。但是两者的解决方式类似，都是通过向发送端发送控制报文来缓解。

​	出现拥塞的条件可以描述为：
$$
\sum{对资源的需求} > 可用资源
$$
> 有一个必须理解的点是，拥塞控制的解决依赖于互联网整体资源的提升，单一或者部分资源的提升并不能解决问题，反而可能使得拥塞更严重，比如对某些短板资源造成更大的压力

**拥塞控制的作用**

<img src="5_运输层.assets/1573279933882.png" alt="1573279933882" style="zoom:67%;" />

​	拥塞属于互联网整体的问题，属于复杂系统的问题，课本提到的解决方式属于开环控制的方式，提到的几个解决方案都属于“启发式”的方式或是调整。

#### four mechanism

> 拥塞窗口：基于窗口的控制，拥塞控制算法的结果体现在对滑动窗口大小的控制上，这里忽略了滑动窗口的其他影响因素
>
> 门限值：当达到门限值的时候开始使用拥塞避免

<img src="5_运输层.assets/1573443278708.png" alt="1573443278708" style="zoom:67%;" />

> 这里注意3，本来能增长到16，但是到12的时候就卡住了，因此只到12。

##### 慢开始(slow-start)

​	慢指的是开始传的时候速度慢，但是增长的速度是很快的，像是上面为几何级数

##### 拥塞避免(congestion avoidance)

​	拥塞窗口的增长进入线性模式

> 图中(1)号点，网络出现超时，因此发送方判断出现拥塞，将门限调整为拥塞窗口的一半，拥塞窗口设为1

##### 快重传(fast retransmit)

​	“要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认”，目的是让发送方尽快知道个别数据报的丢失。比如下面这个例子即上图中的(4)号点，接收方在收到$M_4$后发现缺失$M_3$，于是马上发送了3个$M_2$的ACK。

<img src="5_运输层.assets/1573444625106.png" alt="1573444625106" style="zoom: 50%;" />

> 3ACK能让发送方知道只是部分分组丢失，因此进入快恢复

##### 快恢复(fast recovery)

​	门限调为拥塞窗口的一半，拥塞窗口设为门限值。发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是把 cwnd 值设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法

**AIMD**：加法增大，乘法减小。指的是拥塞避免阶段的拥塞窗口线性增长，以防止网络过早出现拥塞。而在快恢复时，门限调为拥塞窗口的一半，当网络频繁出现拥塞时， ssthresh 值就下降得很快，以大大减少注入到网络中的分组数。

#### 拥塞控制流程图

<img src="5_运输层.assets/1573456618066.png" alt="1573456618066" style="zoom: 80%;" />

#### 主动队列管理AQM

​	网络层的策略对 TCP 拥塞控制影响最大的就是路由器的分组丢弃策略。目前，我们对路由器的缓存的认识是FIFO和尾部丢弃策略。一个IP数据报可能复用着多个TCP连接的信息，因此分组丢弃可能引起多个TCP连接进入慢开始，称为全局同步。

> 全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多  

AQM -- 所谓“主动”就是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组。这样就太被动了。应当在队列长度达到某个值得警惕的数值时（即当网络拥塞有了某些拥塞征兆时），就主动丢弃到达的分组。